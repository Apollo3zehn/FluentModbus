<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Class ModbusClient
 | FluentModbus </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Class ModbusClient
 | FluentModbus ">
      
      <link rel="icon" href="../images/icon.png">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/Apollo3zehn/FluentModbus/new/dev/apiSpec/new?filename=FluentModbus_ModbusClient.md&amp;value=---%0Auid%3A%20FluentModbus.ModbusClient%0Asummary%3A%20&#39;*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax&#39;%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">
  </head>

  <script type="module">
    import options from './../public/main.js'
    import { init } from './../public/docfx.min.js'
    init(options)
  </script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="ManagedReference">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../images/logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="FluentModbus.ModbusClient">



  <h1 id="FluentModbus_ModbusClient" data-uid="FluentModbus.ModbusClient" class="text-break">
    Class ModbusClient
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClientAsync.cs/#L11"><i class="bi bi-code-slash"></i></a>
  </h1>

  <div class="facts text-secondary">
    <dl><dt>Namespace</dt><dd><a class="xref" href="FluentModbus.html">FluentModbus</a></dd></dl>
  <dl><dt>Assembly</dt><dd>FluentModbus.dll</dd></dl>
  </div>

  <div class="markdown summary"><p>A base class for Modbus client implementations.</p>
</div>
  <div class="markdown conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public abstract class ModbusClient</code></pre>
  </div>




  <dl class="typelist inheritance">
    <dt>Inheritance</dt>
    <dd>
      <div><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object">object</a></div>
      <div><span class="xref">ModbusClient</span></div>
    </dd>
  </dl>


  <dl class="typelist derived">
    <dt>Derived</dt>
    <dd>
      <div><a class="xref" href="FluentModbus.ModbusRtuClient.html">ModbusRtuClient</a></div>
      <div><a class="xref" href="FluentModbus.ModbusTcpClient.html">ModbusTcpClient</a></div>
    </dd>
  </dl>







  <h2 class="section" id="methods">Methods
</h2>


  <a id="FluentModbus_ModbusClient_MaskWriteRegister_" data-uid="FluentModbus.ModbusClient.MaskWriteRegister*"></a>

  <h3 id="FluentModbus_ModbusClient_MaskWriteRegister" data-uid="FluentModbus.ModbusClient.MaskWriteRegister">
  MaskWriteRegister()
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClient.cs/#L486"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>This methdod is not implemented.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;This method is not implemented.&quot;)]
public void MaskWriteRegister()</code></pre>
  </div>













  <a id="FluentModbus_ModbusClient_MaskWriteRegisterAsync_" data-uid="FluentModbus.ModbusClient.MaskWriteRegisterAsync*"></a>

  <h3 id="FluentModbus_ModbusClient_MaskWriteRegisterAsync" data-uid="FluentModbus.ModbusClient.MaskWriteRegisterAsync">
  MaskWriteRegisterAsync()
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClientAsync.cs/#L407"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>This methdod is not implemented.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;This method is not implemented.&quot;)]
public Task MaskWriteRegisterAsync()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task">Task</a></dt>
    <dd></dd>
  </dl>











  <a id="FluentModbus_ModbusClient_ReadCoils_" data-uid="FluentModbus.ModbusClient.ReadCoils*"></a>

  <h3 id="FluentModbus_ModbusClient_ReadCoils_System_Int32_System_Int32_System_Int32_" data-uid="FluentModbus.ModbusClient.ReadCoils(System.Int32,System.Int32,System.Int32)">
  ReadCoils(int, int, int)
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClient.cs/#L224"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Reads the specified number of coils as byte array. Each bit of the returned array represents a single coil.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Span&lt;byte&gt; ReadCoils(int unitIdentifier, int startingAddress, int quantity)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The unit identifier is used to communicate via devices such as bridges, routers and gateways that use a single IP address to support multiple independent Modbus end units. Thus, the unit identifier is the address of a remote slave connected on a serial line or on other buses. Use the default values 0x00 or 0xFF when communicating to a Modbus server that is directly connected to a TCP/IP network.</p>
</dd>
    <dt><code>startingAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The coil start address for the read operation.</p>
</dd>
    <dt><code>quantity</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The number of coils to read.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="FluentModbus_ModbusClient_ReadCoilsAsync_" data-uid="FluentModbus.ModbusClient.ReadCoilsAsync*"></a>

  <h3 id="FluentModbus_ModbusClient_ReadCoilsAsync_System_Int32_System_Int32_System_Int32_System_Threading_CancellationToken_" data-uid="FluentModbus.ModbusClient.ReadCoilsAsync(System.Int32,System.Int32,System.Int32,System.Threading.CancellationToken)">
  ReadCoilsAsync(int, int, int, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClientAsync.cs/#L139"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Reads the specified number of coils as byte array. Each bit of the returned array represents a single coil.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Task&lt;Memory&lt;byte&gt;&gt; ReadCoilsAsync(int unitIdentifier, int startingAddress, int quantity, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The unit identifier is used to communicate via devices such as bridges, routers and gateways that use a single IP address to support multiple independent Modbus end units. Thus, the unit identifier is the address of a remote slave connected on a serial line or on other buses. Use the default values 0x00 or 0xFF when communicating to a Modbus server that is directly connected to a TCP/IP network.</p>
</dd>
    <dt><code>startingAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The coil start address for the read operation.</p>
</dd>
    <dt><code>quantity</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The number of coils to read.</p>
</dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd><p>The token to monitor for cancellation requests. The default value is <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken.none">None</a>.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.memory-1">Memory</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;&gt;</dt>
    <dd></dd>
  </dl>











  <a id="FluentModbus_ModbusClient_ReadDiscreteInputs_" data-uid="FluentModbus.ModbusClient.ReadDiscreteInputs*"></a>

  <h3 id="FluentModbus_ModbusClient_ReadDiscreteInputs_System_Int32_System_Int32_System_Int32_" data-uid="FluentModbus.ModbusClient.ReadDiscreteInputs(System.Int32,System.Int32,System.Int32)">
  ReadDiscreteInputs(int, int, int)
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClient.cs/#L258"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Reads the specified number of discrete inputs as byte array. Each bit of the returned array represents a single discrete input.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Span&lt;byte&gt; ReadDiscreteInputs(int unitIdentifier, int startingAddress, int quantity)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The unit identifier is used to communicate via devices such as bridges, routers and gateways that use a single IP address to support multiple independent Modbus end units. Thus, the unit identifier is the address of a remote slave connected on a serial line or on other buses. Use the default values 0x00 or 0xFF when communicating to a Modbus server that is directly connected to a TCP/IP network.</p>
</dd>
    <dt><code>startingAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The discrete input start address for the read operation.</p>
</dd>
    <dt><code>quantity</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The number of discrete inputs to read.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="FluentModbus_ModbusClient_ReadDiscreteInputsAsync_" data-uid="FluentModbus.ModbusClient.ReadDiscreteInputsAsync*"></a>

  <h3 id="FluentModbus_ModbusClient_ReadDiscreteInputsAsync_System_Int32_System_Int32_System_Int32_System_Threading_CancellationToken_" data-uid="FluentModbus.ModbusClient.ReadDiscreteInputsAsync(System.Int32,System.Int32,System.Int32,System.Threading.CancellationToken)">
  ReadDiscreteInputsAsync(int, int, int, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClientAsync.cs/#L174"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Reads the specified number of discrete inputs as byte array. Each bit of the returned array represents a single discrete input.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Task&lt;Memory&lt;byte&gt;&gt; ReadDiscreteInputsAsync(int unitIdentifier, int startingAddress, int quantity, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The unit identifier is used to communicate via devices such as bridges, routers and gateways that use a single IP address to support multiple independent Modbus end units. Thus, the unit identifier is the address of a remote slave connected on a serial line or on other buses. Use the default values 0x00 or 0xFF when communicating to a Modbus server that is directly connected to a TCP/IP network.</p>
</dd>
    <dt><code>startingAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The discrete input start address for the read operation.</p>
</dd>
    <dt><code>quantity</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The number of discrete inputs to read.</p>
</dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd><p>The token to monitor for cancellation requests. The default value is <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken.none">None</a>.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.memory-1">Memory</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;&gt;</dt>
    <dd></dd>
  </dl>











  <a id="FluentModbus_ModbusClient_ReadFifoQueue_" data-uid="FluentModbus.ModbusClient.ReadFifoQueue*"></a>

  <h3 id="FluentModbus_ModbusClient_ReadFifoQueue" data-uid="FluentModbus.ModbusClient.ReadFifoQueue">
  ReadFifoQueue()
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClient.cs/#L572"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>This methdod is not implemented.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;This method is not implemented.&quot;)]
public void ReadFifoQueue()</code></pre>
  </div>













  <a id="FluentModbus_ModbusClient_ReadFifoQueueAsync_" data-uid="FluentModbus.ModbusClient.ReadFifoQueueAsync*"></a>

  <h3 id="FluentModbus_ModbusClient_ReadFifoQueueAsync" data-uid="FluentModbus.ModbusClient.ReadFifoQueueAsync">
  ReadFifoQueueAsync()
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClientAsync.cs/#L495"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>This methdod is not implemented.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;This method is not implemented.&quot;)]
public Task ReadFifoQueueAsync()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task">Task</a></dt>
    <dd></dd>
  </dl>











  <a id="FluentModbus_ModbusClient_ReadFileRecord_" data-uid="FluentModbus.ModbusClient.ReadFileRecord*"></a>

  <h3 id="FluentModbus_ModbusClient_ReadFileRecord" data-uid="FluentModbus.ModbusClient.ReadFileRecord">
  ReadFileRecord()
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClient.cs/#L468"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>This methdod is not implemented.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;This method is not implemented.&quot;)]
public void ReadFileRecord()</code></pre>
  </div>













  <a id="FluentModbus_ModbusClient_ReadFileRecordAsync_" data-uid="FluentModbus.ModbusClient.ReadFileRecordAsync*"></a>

  <h3 id="FluentModbus_ModbusClient_ReadFileRecordAsync" data-uid="FluentModbus.ModbusClient.ReadFileRecordAsync">
  ReadFileRecordAsync()
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClientAsync.cs/#L389"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>This methdod is not implemented.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;This method is not implemented.&quot;)]
public Task ReadFileRecordAsync()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task">Task</a></dt>
    <dd></dd>
  </dl>











  <a id="FluentModbus_ModbusClient_ReadHoldingRegisters_" data-uid="FluentModbus.ModbusClient.ReadHoldingRegisters*"></a>

  <h3 id="FluentModbus_ModbusClient_ReadHoldingRegisters_System_Byte_System_UInt16_System_UInt16_" data-uid="FluentModbus.ModbusClient.ReadHoldingRegisters(System.Byte,System.UInt16,System.UInt16)">
  ReadHoldingRegisters(byte, ushort, ushort)
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClient.cs/#L140"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Low level API. Use the generic version of this method for easier access. Reads the specified number of values as byte array from the holding registers.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Span&lt;byte&gt; ReadHoldingRegisters(byte unitIdentifier, ushort startingAddress, ushort quantity)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The unit identifier is used to communicate via devices such as bridges, routers and gateways that use a single IP address to support multiple independent Modbus end units. Thus, the unit identifier is the address of a remote slave connected on a serial line or on other buses. Use the default values 0x00 or 0xFF when communicating to a Modbus server that is directly connected to a TCP/IP network.</p>
</dd>
    <dt><code>startingAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.uint16">ushort</a></dt>
    <dd><p>The holding register start address for the read operation.</p>
</dd>
    <dt><code>quantity</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.uint16">ushort</a></dt>
    <dd><p>The number of holding registers (16 bit per register) to read.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="FluentModbus_ModbusClient_ReadHoldingRegistersAsync_" data-uid="FluentModbus.ModbusClient.ReadHoldingRegistersAsync*"></a>

  <h3 id="FluentModbus_ModbusClient_ReadHoldingRegistersAsync_System_Byte_System_UInt16_System_UInt16_System_Threading_CancellationToken_" data-uid="FluentModbus.ModbusClient.ReadHoldingRegistersAsync(System.Byte,System.UInt16,System.UInt16,System.Threading.CancellationToken)">
  ReadHoldingRegistersAsync(byte, ushort, ushort, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClientAsync.cs/#L52"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Low level API. Use the generic version of this method for easier access. Reads the specified number of values as byte array from the holding registers.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Task&lt;Memory&lt;byte&gt;&gt; ReadHoldingRegistersAsync(byte unitIdentifier, ushort startingAddress, ushort quantity, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The unit identifier is used to communicate via devices such as bridges, routers and gateways that use a single IP address to support multiple independent Modbus end units. Thus, the unit identifier is the address of a remote slave connected on a serial line or on other buses. Use the default values 0x00 or 0xFF when communicating to a Modbus server that is directly connected to a TCP/IP network.</p>
</dd>
    <dt><code>startingAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.uint16">ushort</a></dt>
    <dd><p>The holding register start address for the read operation.</p>
</dd>
    <dt><code>quantity</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.uint16">ushort</a></dt>
    <dd><p>The number of holding registers (16 bit per register) to read.</p>
</dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd><p>The token to monitor for cancellation requests. The default value is <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken.none">None</a>.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.memory-1">Memory</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;&gt;</dt>
    <dd></dd>
  </dl>











  <a id="FluentModbus_ModbusClient_ReadHoldingRegistersAsync_" data-uid="FluentModbus.ModbusClient.ReadHoldingRegistersAsync*"></a>

  <h3 id="FluentModbus_ModbusClient_ReadHoldingRegistersAsync__1_System_Int32_System_Int32_System_Int32_System_Threading_CancellationToken_" data-uid="FluentModbus.ModbusClient.ReadHoldingRegistersAsync``1(System.Int32,System.Int32,System.Int32,System.Threading.CancellationToken)">
  ReadHoldingRegistersAsync&lt;T&gt;(int, int, int, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClientAsync.cs/#L30"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Reads the specified number of values of type <code class="typeparamref">T</code> from the holding registers.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Task&lt;Memory&lt;T&gt;&gt; ReadHoldingRegistersAsync&lt;T&gt;(int unitIdentifier, int startingAddress, int count, CancellationToken cancellationToken = default) where T : unmanaged</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The unit identifier is used to communicate via devices such as bridges, routers and gateways that use a single IP address to support multiple independent Modbus end units. Thus, the unit identifier is the address of a remote slave connected on a serial line or on other buses. Use the default values 0x00 or 0xFF when communicating to a Modbus server that is directly connected to a TCP/IP network.</p>
</dd>
    <dt><code>startingAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The holding register start address for the read operation.</p>
</dd>
    <dt><code>count</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The number of elements of type <code class="typeparamref">T</code> to read.</p>
</dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd><p>The token to monitor for cancellation requests. The default value is <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken.none">None</a>.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.memory-1">Memory</a>&lt;T&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>T</code></dt>
    <dd><p>Determines the type of the returned data.</p>
</dd>
  </dl>










  <a id="FluentModbus_ModbusClient_ReadHoldingRegisters_" data-uid="FluentModbus.ModbusClient.ReadHoldingRegisters*"></a>

  <h3 id="FluentModbus_ModbusClient_ReadHoldingRegisters__1_System_Int32_System_Int32_System_Int32_" data-uid="FluentModbus.ModbusClient.ReadHoldingRegisters``1(System.Int32,System.Int32,System.Int32)">
  ReadHoldingRegisters&lt;T&gt;(int, int, int)
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClient.cs/#L119"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Reads the specified number of values of type <code class="typeparamref">T</code> from the holding registers.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Span&lt;T&gt; ReadHoldingRegisters&lt;T&gt;(int unitIdentifier, int startingAddress, int count) where T : unmanaged</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The unit identifier is used to communicate via devices such as bridges, routers and gateways that use a single IP address to support multiple independent Modbus end units. Thus, the unit identifier is the address of a remote slave connected on a serial line or on other buses. Use the default values 0x00 or 0xFF when communicating to a Modbus server that is directly connected to a TCP/IP network.</p>
</dd>
    <dt><code>startingAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The holding register start address for the read operation.</p>
</dd>
    <dt><code>count</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The number of elements of type <code class="typeparamref">T</code> to read.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;T&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>T</code></dt>
    <dd><p>Determines the type of the returned data.</p>
</dd>
  </dl>










  <a id="FluentModbus_ModbusClient_ReadInputRegisters_" data-uid="FluentModbus.ModbusClient.ReadInputRegisters*"></a>

  <h3 id="FluentModbus_ModbusClient_ReadInputRegisters_System_Byte_System_UInt16_System_UInt16_" data-uid="FluentModbus.ModbusClient.ReadInputRegisters(System.Byte,System.UInt16,System.UInt16)">
  ReadInputRegisters(byte, ushort, ushort)
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClient.cs/#L314"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Low level API. Use the generic version of this method for easier access. Reads the specified number of values as byte array from the input registers.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Span&lt;byte&gt; ReadInputRegisters(byte unitIdentifier, ushort startingAddress, ushort quantity)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The unit identifier is used to communicate via devices such as bridges, routers and gateways that use a single IP address to support multiple independent Modbus end units. Thus, the unit identifier is the address of a remote slave connected on a serial line or on other buses. Use the default values 0x00 or 0xFF when communicating to a Modbus server that is directly connected to a TCP/IP network.</p>
</dd>
    <dt><code>startingAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.uint16">ushort</a></dt>
    <dd><p>The input register start address for the read operation.</p>
</dd>
    <dt><code>quantity</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.uint16">ushort</a></dt>
    <dd><p>The number of input registers (16 bit per register) to read.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="FluentModbus_ModbusClient_ReadInputRegistersAsync_" data-uid="FluentModbus.ModbusClient.ReadInputRegistersAsync*"></a>

  <h3 id="FluentModbus_ModbusClient_ReadInputRegistersAsync_System_Byte_System_UInt16_System_UInt16_System_Threading_CancellationToken_" data-uid="FluentModbus.ModbusClient.ReadInputRegistersAsync(System.Byte,System.UInt16,System.UInt16,System.Threading.CancellationToken)">
  ReadInputRegistersAsync(byte, ushort, ushort, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClientAsync.cs/#L232"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Low level API. Use the generic version of this method for easier access. Reads the specified number of values as byte array from the input registers.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Task&lt;Memory&lt;byte&gt;&gt; ReadInputRegistersAsync(byte unitIdentifier, ushort startingAddress, ushort quantity, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The unit identifier is used to communicate via devices such as bridges, routers and gateways that use a single IP address to support multiple independent Modbus end units. Thus, the unit identifier is the address of a remote slave connected on a serial line or on other buses. Use the default values 0x00 or 0xFF when communicating to a Modbus server that is directly connected to a TCP/IP network.</p>
</dd>
    <dt><code>startingAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.uint16">ushort</a></dt>
    <dd><p>The input register start address for the read operation.</p>
</dd>
    <dt><code>quantity</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.uint16">ushort</a></dt>
    <dd><p>The number of input registers (16 bit per register) to read.</p>
</dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd><p>The token to monitor for cancellation requests. The default value is <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken.none">None</a>.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.memory-1">Memory</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;&gt;</dt>
    <dd></dd>
  </dl>











  <a id="FluentModbus_ModbusClient_ReadInputRegistersAsync_" data-uid="FluentModbus.ModbusClient.ReadInputRegistersAsync*"></a>

  <h3 id="FluentModbus_ModbusClient_ReadInputRegistersAsync__1_System_Int32_System_Int32_System_Int32_System_Threading_CancellationToken_" data-uid="FluentModbus.ModbusClient.ReadInputRegistersAsync``1(System.Int32,System.Int32,System.Int32,System.Threading.CancellationToken)">
  ReadInputRegistersAsync&lt;T&gt;(int, int, int, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClientAsync.cs/#L210"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Reads the specified number of values of type <code class="typeparamref">T</code> from the input registers.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Task&lt;Memory&lt;T&gt;&gt; ReadInputRegistersAsync&lt;T&gt;(int unitIdentifier, int startingAddress, int count, CancellationToken cancellationToken = default) where T : unmanaged</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The unit identifier is used to communicate via devices such as bridges, routers and gateways that use a single IP address to support multiple independent Modbus end units. Thus, the unit identifier is the address of a remote slave connected on a serial line or on other buses. Use the default values 0x00 or 0xFF when communicating to a Modbus server that is directly connected to a TCP/IP network.</p>
</dd>
    <dt><code>startingAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The input register start address for the read operation.</p>
</dd>
    <dt><code>count</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The number of elements of type <code class="typeparamref">T</code> to read.</p>
</dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd><p>The token to monitor for cancellation requests. The default value is <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken.none">None</a>.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.memory-1">Memory</a>&lt;T&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>T</code></dt>
    <dd><p>Determines the type of the returned data.</p>
</dd>
  </dl>










  <a id="FluentModbus_ModbusClient_ReadInputRegisters_" data-uid="FluentModbus.ModbusClient.ReadInputRegisters*"></a>

  <h3 id="FluentModbus_ModbusClient_ReadInputRegisters__1_System_Int32_System_Int32_System_Int32_" data-uid="FluentModbus.ModbusClient.ReadInputRegisters``1(System.Int32,System.Int32,System.Int32)">
  ReadInputRegisters&lt;T&gt;(int, int, int)
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClient.cs/#L293"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Reads the specified number of values of type <code class="typeparamref">T</code> from the input registers.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Span&lt;T&gt; ReadInputRegisters&lt;T&gt;(int unitIdentifier, int startingAddress, int count) where T : unmanaged</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The unit identifier is used to communicate via devices such as bridges, routers and gateways that use a single IP address to support multiple independent Modbus end units. Thus, the unit identifier is the address of a remote slave connected on a serial line or on other buses. Use the default values 0x00 or 0xFF when communicating to a Modbus server that is directly connected to a TCP/IP network.</p>
</dd>
    <dt><code>startingAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The input register start address for the read operation.</p>
</dd>
    <dt><code>count</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The number of elements of type <code class="typeparamref">T</code> to read.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;T&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>T</code></dt>
    <dd><p>Determines the type of the returned data.</p>
</dd>
  </dl>










  <a id="FluentModbus_ModbusClient_ReadWriteMultipleRegisters_" data-uid="FluentModbus.ModbusClient.ReadWriteMultipleRegisters*"></a>

  <h3 id="FluentModbus_ModbusClient_ReadWriteMultipleRegisters_System_Byte_System_UInt16_System_UInt16_System_UInt16_System_Byte___" data-uid="FluentModbus.ModbusClient.ReadWriteMultipleRegisters(System.Byte,System.UInt16,System.UInt16,System.UInt16,System.Byte[])">
  ReadWriteMultipleRegisters(byte, ushort, ushort, ushort, byte[])
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClient.cs/#L532"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Low level API. Use the generic version of this method for easier access. Reads the specified number of values as byte array from and writes the provided byte array to the holding registers. The write operation is performed before the read.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Span&lt;byte&gt; ReadWriteMultipleRegisters(byte unitIdentifier, ushort readStartingAddress, ushort readQuantity, ushort writeStartingAddress, byte[] dataset)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The unit identifier is used to communicate via devices such as bridges, routers and gateways that use a single IP address to support multiple independent Modbus end units. Thus, the unit identifier is the address of a remote slave connected on a serial line or on other buses. Use the default values 0x00 or 0xFF when communicating to a Modbus server that is directly connected to a TCP/IP network.</p>
</dd>
    <dt><code>readStartingAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.uint16">ushort</a></dt>
    <dd><p>The holding register start address for the read operation.</p>
</dd>
    <dt><code>readQuantity</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.uint16">ushort</a></dt>
    <dd><p>The number of holding registers (16 bit per register) to read.</p>
</dd>
    <dt><code>writeStartingAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.uint16">ushort</a></dt>
    <dd><p>The holding register start address for the write operation.</p>
</dd>
    <dt><code>dataset</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>[]</dt>
    <dd><p>The byte array to write to the server. A minimum of two bytes is required.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="FluentModbus_ModbusClient_ReadWriteMultipleRegistersAsync_" data-uid="FluentModbus.ModbusClient.ReadWriteMultipleRegistersAsync*"></a>

  <h3 id="FluentModbus_ModbusClient_ReadWriteMultipleRegistersAsync_System_Byte_System_UInt16_System_UInt16_System_UInt16_System_Byte___System_Threading_CancellationToken_" data-uid="FluentModbus.ModbusClient.ReadWriteMultipleRegistersAsync(System.Byte,System.UInt16,System.UInt16,System.UInt16,System.Byte[],System.Threading.CancellationToken)">
  ReadWriteMultipleRegistersAsync(byte, ushort, ushort, ushort, byte[], CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClientAsync.cs/#L455"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Low level API. Use the generic version of this method for easier access. Reads the specified number of values as byte array from and writes the provided byte array to the holding registers. The write operation is performed before the read.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Task&lt;Memory&lt;byte&gt;&gt; ReadWriteMultipleRegistersAsync(byte unitIdentifier, ushort readStartingAddress, ushort readQuantity, ushort writeStartingAddress, byte[] dataset, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The unit identifier is used to communicate via devices such as bridges, routers and gateways that use a single IP address to support multiple independent Modbus end units. Thus, the unit identifier is the address of a remote slave connected on a serial line or on other buses. Use the default values 0x00 or 0xFF when communicating to a Modbus server that is directly connected to a TCP/IP network.</p>
</dd>
    <dt><code>readStartingAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.uint16">ushort</a></dt>
    <dd><p>The holding register start address for the read operation.</p>
</dd>
    <dt><code>readQuantity</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.uint16">ushort</a></dt>
    <dd><p>The number of holding registers (16 bit per register) to read.</p>
</dd>
    <dt><code>writeStartingAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.uint16">ushort</a></dt>
    <dd><p>The holding register start address for the write operation.</p>
</dd>
    <dt><code>dataset</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>[]</dt>
    <dd><p>The byte array to write to the server. A minimum of two bytes is required.</p>
</dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd><p>The token to monitor for cancellation requests. The default value is <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken.none">None</a>.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.memory-1">Memory</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;&gt;</dt>
    <dd></dd>
  </dl>











  <a id="FluentModbus_ModbusClient_ReadWriteMultipleRegistersAsync_" data-uid="FluentModbus.ModbusClient.ReadWriteMultipleRegistersAsync*"></a>

  <h3 id="FluentModbus_ModbusClient_ReadWriteMultipleRegistersAsync__2_System_Int32_System_Int32_System_Int32_System_Int32___1___System_Threading_CancellationToken_" data-uid="FluentModbus.ModbusClient.ReadWriteMultipleRegistersAsync``2(System.Int32,System.Int32,System.Int32,System.Int32,``1[],System.Threading.CancellationToken)">
  ReadWriteMultipleRegistersAsync&lt;TRead, TWrite&gt;(int, int, int, int, TWrite[], CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClientAsync.cs/#L424"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Reads the specified number of values of type <code class="typeparamref">TRead</code> from and writes the provided array of type <code class="typeparamref">TWrite</code> to the holding registers. The write operation is performed before the read.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Task&lt;Memory&lt;TRead&gt;&gt; ReadWriteMultipleRegistersAsync&lt;TRead, TWrite&gt;(int unitIdentifier, int readStartingAddress, int readCount, int writeStartingAddress, TWrite[] dataset, CancellationToken cancellationToken = default) where TRead : unmanaged where TWrite : unmanaged</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The unit identifier is used to communicate via devices such as bridges, routers and gateways that use a single IP address to support multiple independent Modbus end units. Thus, the unit identifier is the address of a remote slave connected on a serial line or on other buses. Use the default values 0x00 or 0xFF when communicating to a Modbus server that is directly connected to a TCP/IP network.</p>
</dd>
    <dt><code>readStartingAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The holding register start address for the read operation.</p>
</dd>
    <dt><code>readCount</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The number of elements of type <code class="typeparamref">TRead</code> to read.</p>
</dd>
    <dt><code>writeStartingAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The holding register start address for the write operation.</p>
</dd>
    <dt><code>dataset</code> TWrite[]</dt>
    <dd><p>The data of type <code class="typeparamref">TWrite</code> to write to the server.</p>
</dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd><p>The token to monitor for cancellation requests. The default value is <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken.none">None</a>.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.memory-1">Memory</a>&lt;TRead&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TRead</code></dt>
    <dd><p>Determines the type of the returned data.</p>
</dd>
    <dt><code>TWrite</code></dt>
    <dd><p>Determines the type of the provided data.</p>
</dd>
  </dl>










  <a id="FluentModbus_ModbusClient_ReadWriteMultipleRegisters_" data-uid="FluentModbus.ModbusClient.ReadWriteMultipleRegisters*"></a>

  <h3 id="FluentModbus_ModbusClient_ReadWriteMultipleRegisters__2_System_Int32_System_Int32_System_Int32_System_Int32___1___" data-uid="FluentModbus.ModbusClient.ReadWriteMultipleRegisters``2(System.Int32,System.Int32,System.Int32,System.Int32,``1[])">
  ReadWriteMultipleRegisters&lt;TRead, TWrite&gt;(int, int, int, int, TWrite[])
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClient.cs/#L502"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Reads the specified number of values of type <code class="typeparamref">TRead</code> from and writes the provided array of type <code class="typeparamref">TWrite</code> to the holding registers. The write operation is performed before the read.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Span&lt;TRead&gt; ReadWriteMultipleRegisters&lt;TRead, TWrite&gt;(int unitIdentifier, int readStartingAddress, int readCount, int writeStartingAddress, TWrite[] dataset) where TRead : unmanaged where TWrite : unmanaged</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The unit identifier is used to communicate via devices such as bridges, routers and gateways that use a single IP address to support multiple independent Modbus end units. Thus, the unit identifier is the address of a remote slave connected on a serial line or on other buses. Use the default values 0x00 or 0xFF when communicating to a Modbus server that is directly connected to a TCP/IP network.</p>
</dd>
    <dt><code>readStartingAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The holding register start address for the read operation.</p>
</dd>
    <dt><code>readCount</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The number of elements of type <code class="typeparamref">TRead</code> to read.</p>
</dd>
    <dt><code>writeStartingAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The holding register start address for the write operation.</p>
</dd>
    <dt><code>dataset</code> TWrite[]</dt>
    <dd><p>The data of type <code class="typeparamref">TWrite</code> to write to the server.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;TRead&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TRead</code></dt>
    <dd><p>Determines the type of the returned data.</p>
</dd>
    <dt><code>TWrite</code></dt>
    <dd><p>Determines the type of the provided data.</p>
</dd>
  </dl>










  <a id="FluentModbus_ModbusClient_TransceiveFrame_" data-uid="FluentModbus.ModbusClient.TransceiveFrame*"></a>

  <h3 id="FluentModbus_ModbusClient_TransceiveFrame_System_Byte_FluentModbus_ModbusFunctionCode_System_Action_FluentModbus_ExtendedBinaryWriter__" data-uid="FluentModbus.ModbusClient.TransceiveFrame(System.Byte,FluentModbus.ModbusFunctionCode,System.Action{FluentModbus.ExtendedBinaryWriter})">
  TransceiveFrame(byte, ModbusFunctionCode, Action&lt;ExtendedBinaryWriter&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClient.cs/#L25"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Sends the requested modbus message and waits for the response.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">protected abstract Span&lt;byte&gt; TransceiveFrame(byte unitIdentifier, ModbusFunctionCode functionCode, Action&lt;ExtendedBinaryWriter&gt; extendFrame)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The unit identifier.</p>
</dd>
    <dt><code>functionCode</code> <a class="xref" href="FluentModbus.ModbusFunctionCode.html">ModbusFunctionCode</a></dt>
    <dd><p>The function code.</p>
</dd>
    <dt><code>extendFrame</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="FluentModbus.ExtendedBinaryWriter.html">ExtendedBinaryWriter</a>&gt;</dt>
    <dd><p>An action to be called to extend the prepared Modbus frame with function code specific data.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="FluentModbus_ModbusClient_TransceiveFrameAsync_" data-uid="FluentModbus.ModbusClient.TransceiveFrameAsync*"></a>

  <h3 id="FluentModbus_ModbusClient_TransceiveFrameAsync_System_Byte_FluentModbus_ModbusFunctionCode_System_Action_FluentModbus_ExtendedBinaryWriter__System_Threading_CancellationToken_" data-uid="FluentModbus.ModbusClient.TransceiveFrameAsync(System.Byte,FluentModbus.ModbusFunctionCode,System.Action{FluentModbus.ExtendedBinaryWriter},System.Threading.CancellationToken)">
  TransceiveFrameAsync(byte, ModbusFunctionCode, Action&lt;ExtendedBinaryWriter&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClientAsync.cs/#L20"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Sends the requested modbus message and waits for the response.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">protected abstract Task&lt;Memory&lt;byte&gt;&gt; TransceiveFrameAsync(byte unitIdentifier, ModbusFunctionCode functionCode, Action&lt;ExtendedBinaryWriter&gt; extendFrame, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The unit identifier.</p>
</dd>
    <dt><code>functionCode</code> <a class="xref" href="FluentModbus.ModbusFunctionCode.html">ModbusFunctionCode</a></dt>
    <dd><p>The function code.</p>
</dd>
    <dt><code>extendFrame</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="FluentModbus.ExtendedBinaryWriter.html">ExtendedBinaryWriter</a>&gt;</dt>
    <dd><p>An action to be called to extend the prepared Modbus frame with function code specific data.</p>
</dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd><p>The token to monitor for cancellation requests. The default value is <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken.none">None</a>.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.memory-1">Memory</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;&gt;</dt>
    <dd></dd>
  </dl>











  <a id="FluentModbus_ModbusClient_WriteFileRecord_" data-uid="FluentModbus.ModbusClient.WriteFileRecord*"></a>

  <h3 id="FluentModbus_ModbusClient_WriteFileRecord" data-uid="FluentModbus.ModbusClient.WriteFileRecord">
  WriteFileRecord()
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClient.cs/#L477"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>This methdod is not implemented.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;This method is not implemented.&quot;)]
public void WriteFileRecord()</code></pre>
  </div>













  <a id="FluentModbus_ModbusClient_WriteFileRecordAsync_" data-uid="FluentModbus.ModbusClient.WriteFileRecordAsync*"></a>

  <h3 id="FluentModbus_ModbusClient_WriteFileRecordAsync" data-uid="FluentModbus.ModbusClient.WriteFileRecordAsync">
  WriteFileRecordAsync()
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClientAsync.cs/#L398"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>This methdod is not implemented.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;This method is not implemented.&quot;)]
public Task WriteFileRecordAsync()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task">Task</a></dt>
    <dd></dd>
  </dl>











  <a id="FluentModbus_ModbusClient_WriteMultipleCoils_" data-uid="FluentModbus.ModbusClient.WriteMultipleCoils*"></a>

  <h3 id="FluentModbus_ModbusClient_WriteMultipleCoils_System_Int32_System_Int32_System_Boolean___" data-uid="FluentModbus.ModbusClient.WriteMultipleCoils(System.Int32,System.Int32,System.Boolean[])">
  WriteMultipleCoils(int, int, bool[])
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClient.cs/#L432"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Writes the provided <code class="paramref">values</code> to the coil registers.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void WriteMultipleCoils(int unitIdentifier, int startingAddress, bool[] values)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The unit identifier is used to communicate via devices such as bridges, routers and gateways that use a single IP address to support multiple independent Modbus end units. Thus, the unit identifier is the address of a remote slave connected on a serial line or on other buses. Use the default values 0x00 or 0xFF when communicating to a Modbus server that is directly connected to a TCP/IP network.</p>
</dd>
    <dt><code>startingAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The coil register start address for the write operation.</p>
</dd>
    <dt><code>values</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.boolean">bool</a>[]</dt>
    <dd><p>The values to write to the server.</p>
</dd>
  </dl>












  <a id="FluentModbus_ModbusClient_WriteMultipleCoilsAsync_" data-uid="FluentModbus.ModbusClient.WriteMultipleCoilsAsync*"></a>

  <h3 id="FluentModbus_ModbusClient_WriteMultipleCoilsAsync_System_Int32_System_Int32_System_Boolean___System_Threading_CancellationToken_" data-uid="FluentModbus.ModbusClient.WriteMultipleCoilsAsync(System.Int32,System.Int32,System.Boolean[],System.Threading.CancellationToken)">
  WriteMultipleCoilsAsync(int, int, bool[], CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClientAsync.cs/#L353"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Writes the provided <code class="paramref">values</code> to the coil registers.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void WriteMultipleCoilsAsync(int unitIdentifier, int startingAddress, bool[] values, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The unit identifier is used to communicate via devices such as bridges, routers and gateways that use a single IP address to support multiple independent Modbus end units. Thus, the unit identifier is the address of a remote slave connected on a serial line or on other buses. Use the default values 0x00 or 0xFF when communicating to a Modbus server that is directly connected to a TCP/IP network.</p>
</dd>
    <dt><code>startingAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The coil register start address for the write operation.</p>
</dd>
    <dt><code>values</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.boolean">bool</a>[]</dt>
    <dd><p>The values to write to the server.</p>
</dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd><p>The token to monitor for cancellation requests. The default value is <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken.none">None</a>.</p>
</dd>
  </dl>












  <a id="FluentModbus_ModbusClient_WriteMultipleRegisters_" data-uid="FluentModbus.ModbusClient.WriteMultipleRegisters*"></a>

  <h3 id="FluentModbus_ModbusClient_WriteMultipleRegisters_System_Byte_System_UInt16_System_Byte___" data-uid="FluentModbus.ModbusClient.WriteMultipleRegisters(System.Byte,System.UInt16,System.Byte[])">
  WriteMultipleRegisters(byte, ushort, byte[])
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClient.cs/#L188"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Low level API. Use the generic version of this method for easier access. Writes the provided byte array to the holding registers.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void WriteMultipleRegisters(byte unitIdentifier, ushort startingAddress, byte[] dataset)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The unit identifier is used to communicate via devices such as bridges, routers and gateways that use a single IP address to support multiple independent Modbus end units. Thus, the unit identifier is the address of a remote slave connected on a serial line or on other buses. Use the default values 0x00 or 0xFF when communicating to a Modbus server that is directly connected to a TCP/IP network.</p>
</dd>
    <dt><code>startingAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.uint16">ushort</a></dt>
    <dd><p>The holding register start address for the write operation.</p>
</dd>
    <dt><code>dataset</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>[]</dt>
    <dd><p>The byte array to write to the server. A minimum of two bytes is required.</p>
</dd>
  </dl>












  <a id="FluentModbus_ModbusClient_WriteMultipleRegistersAsync_" data-uid="FluentModbus.ModbusClient.WriteMultipleRegistersAsync*"></a>

  <h3 id="FluentModbus_ModbusClient_WriteMultipleRegistersAsync_System_Byte_System_UInt16_System_Byte___System_Threading_CancellationToken_" data-uid="FluentModbus.ModbusClient.WriteMultipleRegistersAsync(System.Byte,System.UInt16,System.Byte[],System.Threading.CancellationToken)">
  WriteMultipleRegistersAsync(byte, ushort, byte[], CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClientAsync.cs/#L102"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Low level API. Use the generic version of this method for easier access. Writes the provided byte array to the holding registers.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Task WriteMultipleRegistersAsync(byte unitIdentifier, ushort startingAddress, byte[] dataset, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The unit identifier is used to communicate via devices such as bridges, routers and gateways that use a single IP address to support multiple independent Modbus end units. Thus, the unit identifier is the address of a remote slave connected on a serial line or on other buses. Use the default values 0x00 or 0xFF when communicating to a Modbus server that is directly connected to a TCP/IP network.</p>
</dd>
    <dt><code>startingAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.uint16">ushort</a></dt>
    <dd><p>The holding register start address for the write operation.</p>
</dd>
    <dt><code>dataset</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>[]</dt>
    <dd><p>The byte array to write to the server. A minimum of two bytes is required.</p>
</dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd><p>The token to monitor for cancellation requests. The default value is <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken.none">None</a>.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task">Task</a></dt>
    <dd></dd>
  </dl>











  <a id="FluentModbus_ModbusClient_WriteMultipleRegistersAsync_" data-uid="FluentModbus.ModbusClient.WriteMultipleRegistersAsync*"></a>

  <h3 id="FluentModbus_ModbusClient_WriteMultipleRegistersAsync__1_System_Int32_System_Int32___0___System_Threading_CancellationToken_" data-uid="FluentModbus.ModbusClient.WriteMultipleRegistersAsync``1(System.Int32,System.Int32,``0[],System.Threading.CancellationToken)">
  WriteMultipleRegistersAsync&lt;T&gt;(int, int, T[], CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClientAsync.cs/#L84"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Writes the provided array of type <code class="typeparamref">T</code> to the holding registers.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Task WriteMultipleRegistersAsync&lt;T&gt;(int unitIdentifier, int startingAddress, T[] dataset, CancellationToken cancellationToken = default) where T : unmanaged</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The unit identifier is used to communicate via devices such as bridges, routers and gateways that use a single IP address to support multiple independent Modbus end units. Thus, the unit identifier is the address of a remote slave connected on a serial line or on other buses. Use the default values 0x00 or 0xFF when communicating to a Modbus server that is directly connected to a TCP/IP network.</p>
</dd>
    <dt><code>startingAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The holding register start address for the write operation.</p>
</dd>
    <dt><code>dataset</code> T[]</dt>
    <dd><p>The data of type <code class="typeparamref">T</code> to write to the server.</p>
</dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd><p>The token to monitor for cancellation requests. The default value is <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken.none">None</a>.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task">Task</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>T</code></dt>
    <dd><p>Determines the type of the provided data.</p>
</dd>
  </dl>










  <a id="FluentModbus_ModbusClient_WriteMultipleRegisters_" data-uid="FluentModbus.ModbusClient.WriteMultipleRegisters*"></a>

  <h3 id="FluentModbus_ModbusClient_WriteMultipleRegisters__1_System_Int32_System_Int32___0___" data-uid="FluentModbus.ModbusClient.WriteMultipleRegisters``1(System.Int32,System.Int32,``0[])">
  WriteMultipleRegisters&lt;T&gt;(int, int, T[])
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClient.cs/#L171"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Writes the provided array of type <code class="typeparamref">T</code> to the holding registers.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void WriteMultipleRegisters&lt;T&gt;(int unitIdentifier, int startingAddress, T[] dataset) where T : unmanaged</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The unit identifier is used to communicate via devices such as bridges, routers and gateways that use a single IP address to support multiple independent Modbus end units. Thus, the unit identifier is the address of a remote slave connected on a serial line or on other buses. Use the default values 0x00 or 0xFF when communicating to a Modbus server that is directly connected to a TCP/IP network.</p>
</dd>
    <dt><code>startingAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The holding register start address for the write operation.</p>
</dd>
    <dt><code>dataset</code> T[]</dt>
    <dd><p>The data of type <code class="typeparamref">T</code> to write to the server.</p>
</dd>
  </dl>


  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>T</code></dt>
    <dd><p>Determines the type of the provided data.</p>
</dd>
  </dl>










  <a id="FluentModbus_ModbusClient_WriteSingleCoil_" data-uid="FluentModbus.ModbusClient.WriteSingleCoil*"></a>

  <h3 id="FluentModbus_ModbusClient_WriteSingleCoil_System_Int32_System_Int32_System_Boolean_" data-uid="FluentModbus.ModbusClient.WriteSingleCoil(System.Int32,System.Int32,System.Boolean)">
  WriteSingleCoil(int, int, bool)
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClient.cs/#L344"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Writes the provided <code class="paramref">value</code> to the coil registers.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void WriteSingleCoil(int unitIdentifier, int registerAddress, bool value)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The unit identifier is used to communicate via devices such as bridges, routers and gateways that use a single IP address to support multiple independent Modbus end units. Thus, the unit identifier is the address of a remote slave connected on a serial line or on other buses. Use the default values 0x00 or 0xFF when communicating to a Modbus server that is directly connected to a TCP/IP network.</p>
</dd>
    <dt><code>registerAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The coil address for the write operation.</p>
</dd>
    <dt><code>value</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.boolean">bool</a></dt>
    <dd><p>The value to write to the server.</p>
</dd>
  </dl>












  <a id="FluentModbus_ModbusClient_WriteSingleCoilAsync_" data-uid="FluentModbus.ModbusClient.WriteSingleCoilAsync*"></a>

  <h3 id="FluentModbus_ModbusClient_WriteSingleCoilAsync_System_Int32_System_Int32_System_Boolean_System_Threading_CancellationToken_" data-uid="FluentModbus.ModbusClient.WriteSingleCoilAsync(System.Int32,System.Int32,System.Boolean,System.Threading.CancellationToken)">
  WriteSingleCoilAsync(int, int, bool, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClientAsync.cs/#L263"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Writes the provided <code class="paramref">value</code> to the coil registers.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Task WriteSingleCoilAsync(int unitIdentifier, int registerAddress, bool value, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The unit identifier is used to communicate via devices such as bridges, routers and gateways that use a single IP address to support multiple independent Modbus end units. Thus, the unit identifier is the address of a remote slave connected on a serial line or on other buses. Use the default values 0x00 or 0xFF when communicating to a Modbus server that is directly connected to a TCP/IP network.</p>
</dd>
    <dt><code>registerAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The coil address for the write operation.</p>
</dd>
    <dt><code>value</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.boolean">bool</a></dt>
    <dd><p>The value to write to the server.</p>
</dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd><p>The token to monitor for cancellation requests. The default value is <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken.none">None</a>.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task">Task</a></dt>
    <dd></dd>
  </dl>











  <a id="FluentModbus_ModbusClient_WriteSingleRegister_" data-uid="FluentModbus.ModbusClient.WriteSingleRegister*"></a>

  <h3 id="FluentModbus_ModbusClient_WriteSingleRegister_System_Byte_System_UInt16_System_Byte___" data-uid="FluentModbus.ModbusClient.WriteSingleRegister(System.Byte,System.UInt16,System.Byte[])">
  WriteSingleRegister(byte, ushort, byte[])
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClient.cs/#L406"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Low level API. Use the overloads of this method for easier access. Writes the provided byte array to the holding register.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void WriteSingleRegister(byte unitIdentifier, ushort registerAddress, byte[] value)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The unit identifier is used to communicate via devices such as bridges, routers and gateways that use a single IP address to support multiple independent Modbus end units. Thus, the unit identifier is the address of a remote slave connected on a serial line or on other buses. Use the default values 0x00 or 0xFF when communicating to a Modbus server that is directly connected to a TCP/IP network.</p>
</dd>
    <dt><code>registerAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.uint16">ushort</a></dt>
    <dd><p>The holding register address for the write operation.</p>
</dd>
    <dt><code>value</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>[]</dt>
    <dd><p>The value to write to the server, which is passed as a 2-byte array.</p>
</dd>
  </dl>












  <a id="FluentModbus_ModbusClient_WriteSingleRegister_" data-uid="FluentModbus.ModbusClient.WriteSingleRegister*"></a>

  <h3 id="FluentModbus_ModbusClient_WriteSingleRegister_System_Int32_System_Int32_System_Int16_" data-uid="FluentModbus.ModbusClient.WriteSingleRegister(System.Int32,System.Int32,System.Int16)">
  WriteSingleRegister(int, int, short)
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClient.cs/#L372"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Writes the provided <code class="paramref">value</code> to the holding registers.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void WriteSingleRegister(int unitIdentifier, int registerAddress, short value)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The unit identifier is used to communicate via devices such as bridges, routers and gateways that use a single IP address to support multiple independent Modbus end units. Thus, the unit identifier is the address of a remote slave connected on a serial line or on other buses. Use the default values 0x00 or 0xFF when communicating to a Modbus server that is directly connected to a TCP/IP network.</p>
</dd>
    <dt><code>registerAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The holding register address for the write operation.</p>
</dd>
    <dt><code>value</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int16">short</a></dt>
    <dd><p>The value to write to the server.</p>
</dd>
  </dl>












  <a id="FluentModbus_ModbusClient_WriteSingleRegister_" data-uid="FluentModbus.ModbusClient.WriteSingleRegister*"></a>

  <h3 id="FluentModbus_ModbusClient_WriteSingleRegister_System_Int32_System_Int32_System_UInt16_" data-uid="FluentModbus.ModbusClient.WriteSingleRegister(System.Int32,System.Int32,System.UInt16)">
  WriteSingleRegister(int, int, ushort)
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClient.cs/#L389"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Writes the provided <code class="paramref">value</code> to the holding registers.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void WriteSingleRegister(int unitIdentifier, int registerAddress, ushort value)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The unit identifier is used to communicate via devices such as bridges, routers and gateways that use a single IP address to support multiple independent Modbus end units. Thus, the unit identifier is the address of a remote slave connected on a serial line or on other buses. Use the default values 0x00 or 0xFF when communicating to a Modbus server that is directly connected to a TCP/IP network.</p>
</dd>
    <dt><code>registerAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The holding register address for the write operation.</p>
</dd>
    <dt><code>value</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.uint16">ushort</a></dt>
    <dd><p>The value to write to the server.</p>
</dd>
  </dl>












  <a id="FluentModbus_ModbusClient_WriteSingleRegisterAsync_" data-uid="FluentModbus.ModbusClient.WriteSingleRegisterAsync*"></a>

  <h3 id="FluentModbus_ModbusClient_WriteSingleRegisterAsync_System_Byte_System_UInt16_System_Byte___System_Threading_CancellationToken_" data-uid="FluentModbus.ModbusClient.WriteSingleRegisterAsync(System.Byte,System.UInt16,System.Byte[],System.Threading.CancellationToken)">
  WriteSingleRegisterAsync(byte, ushort, byte[], CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClientAsync.cs/#L328"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Low level API. Use the overloads of this method for easier access. Writes the provided byte array to the holding register.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Task WriteSingleRegisterAsync(byte unitIdentifier, ushort registerAddress, byte[] value, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The unit identifier is used to communicate via devices such as bridges, routers and gateways that use a single IP address to support multiple independent Modbus end units. Thus, the unit identifier is the address of a remote slave connected on a serial line or on other buses. Use the default values 0x00 or 0xFF when communicating to a Modbus server that is directly connected to a TCP/IP network.</p>
</dd>
    <dt><code>registerAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.uint16">ushort</a></dt>
    <dd><p>The holding register address for the write operation.</p>
</dd>
    <dt><code>value</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>[]</dt>
    <dd><p>The value to write to the server, which is passed as a 2-byte array.</p>
</dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd><p>The token to monitor for cancellation requests. The default value is <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken.none">None</a>.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task">Task</a></dt>
    <dd></dd>
  </dl>











  <a id="FluentModbus_ModbusClient_WriteSingleRegisterAsync_" data-uid="FluentModbus.ModbusClient.WriteSingleRegisterAsync*"></a>

  <h3 id="FluentModbus_ModbusClient_WriteSingleRegisterAsync_System_Int32_System_Int32_System_Int16_System_Threading_CancellationToken_" data-uid="FluentModbus.ModbusClient.WriteSingleRegisterAsync(System.Int32,System.Int32,System.Int16,System.Threading.CancellationToken)">
  WriteSingleRegisterAsync(int, int, short, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClientAsync.cs/#L292"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Writes the provided <code class="paramref">value</code> to the holding registers.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Task WriteSingleRegisterAsync(int unitIdentifier, int registerAddress, short value, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The unit identifier is used to communicate via devices such as bridges, routers and gateways that use a single IP address to support multiple independent Modbus end units. Thus, the unit identifier is the address of a remote slave connected on a serial line or on other buses. Use the default values 0x00 or 0xFF when communicating to a Modbus server that is directly connected to a TCP/IP network.</p>
</dd>
    <dt><code>registerAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The holding register address for the write operation.</p>
</dd>
    <dt><code>value</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int16">short</a></dt>
    <dd><p>The value to write to the server.</p>
</dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd><p>The token to monitor for cancellation requests. The default value is <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken.none">None</a>.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task">Task</a></dt>
    <dd></dd>
  </dl>











  <a id="FluentModbus_ModbusClient_WriteSingleRegisterAsync_" data-uid="FluentModbus.ModbusClient.WriteSingleRegisterAsync*"></a>

  <h3 id="FluentModbus_ModbusClient_WriteSingleRegisterAsync_System_Int32_System_Int32_System_UInt16_System_Threading_CancellationToken_" data-uid="FluentModbus.ModbusClient.WriteSingleRegisterAsync(System.Int32,System.Int32,System.UInt16,System.Threading.CancellationToken)">
  WriteSingleRegisterAsync(int, int, ushort, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClientAsync.cs/#L310"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Writes the provided <code class="paramref">value</code> to the holding registers.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Task WriteSingleRegisterAsync(int unitIdentifier, int registerAddress, ushort value, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>unitIdentifier</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The unit identifier is used to communicate via devices such as bridges, routers and gateways that use a single IP address to support multiple independent Modbus end units. Thus, the unit identifier is the address of a remote slave connected on a serial line or on other buses. Use the default values 0x00 or 0xFF when communicating to a Modbus server that is directly connected to a TCP/IP network.</p>
</dd>
    <dt><code>registerAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The holding register address for the write operation.</p>
</dd>
    <dt><code>value</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.uint16">ushort</a></dt>
    <dd><p>The value to write to the server.</p>
</dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd><p>The token to monitor for cancellation requests. The default value is <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken.none">None</a>.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task">Task</a></dt>
    <dd></dd>
  </dl>












</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/Apollo3zehn/FluentModbus/blob/dev/src/FluentModbus/Client/ModbusClientAsync.cs/#L11" class="edit-link">Edit this page</a>
        </div>

        
      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top">
      <div class="container-xxl">
        <div class="flex-fill">
          Copyright © 2024 Vincent Wilms
        </div>
      </div>
    </footer>
  </body>
</html>