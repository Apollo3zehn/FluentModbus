<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ModbusClient_0x01_IllegalFunction" xml:space="preserve">
    <value>The function code received in the query is not an allowable action for the server. This may be because the function code is only applicable to newer devices, and was not implemented in the unit selected. It could also indicate that the server is in the wrong state to process a request of this type, for example because it is unconfigured and is being asked to return register values.</value>
  </data>
  <data name="ModbusClient_0x02_IllegalDataAddress" xml:space="preserve">
    <value>The data address received in the query is not an allowable address for the server. More specifically, the combination of reference number and transfer length is invalid.</value>
  </data>
  <data name="ModbusClient_0x03_IllegalDataValue" xml:space="preserve">
    <value>A value contained in the query data field is not an allowable value for server. This indicates a fault in the structure of the remainder of a complex request, such as that the implied length is incorrect.</value>
  </data>
  <data name="ModbusClient_0x03_IllegalDataValue_0x7B" xml:space="preserve">
    <value>The quantity of registers is out of range (1..123). Make sure to request a minimum of one register. If you use the generic overload methods, please note that a single register consists of 2 bytes. If, for example, 1 x int32 value is requested, this results in a read operation of 2 registers.</value>
  </data>
  <data name="ModbusClient_0x03_IllegalDataValue_0x7D" xml:space="preserve">
    <value>The quantity of registers is out of range (1..125). Make sure to request a minimum of one register. If you use the generic overload methods, please note that a single register consists of 2 bytes. If, for example, 1 x int32 value is requested, this results in a read operation of 2 registers.</value>
  </data>
  <data name="ModbusClient_0x03_IllegalDataValue_0x7D0" xml:space="preserve">
    <value>The quantity of coils is out of range (1..2000).</value>
  </data>
  <data name="ModbusClient_0x04_ServerDeviceFailure" xml:space="preserve">
    <value>An unrecoverable error occurred while the server was attempting to perform the requested action.</value>
  </data>
  <data name="ModbusClient_0x05_Acknowledge" xml:space="preserve">
    <value>The server has accepted the request and is processing it, but a long duration of time will be required to do so.</value>
  </data>
  <data name="ModbusClient_0x06_ServerDeviceBusy" xml:space="preserve">
    <value>The server is engaged in processing a long–duration program command.</value>
  </data>
  <data name="ModbusClient_0x08_MemoryParityError" xml:space="preserve">
    <value>The server attempted to read record file, but detected a parity error in the memory.</value>
  </data>
  <data name="ModbusClient_0x0A_GatewayPathUnavailable" xml:space="preserve">
    <value>The gateway was unable to allocate an internal communication path from the input port to the output port for processing the request.</value>
  </data>
  <data name="ModbusClient_0x0B_GatewayTargetDeviceFailedToRespond" xml:space="preserve">
    <value>No response was obtained from the target device</value>
  </data>
  <data name="ModbusClient_ArrayLengthMustBeEqualToTwo" xml:space="preserve">
    <value>Array length must be equal to two bytes.</value>
  </data>
  <data name="ModbusClient_ArrayLengthMustBeGreaterThanTwoAndEven" xml:space="preserve">
    <value>Array length must be greater than two bytes and even.</value>
  </data>
  <data name="ModbusClient_InvalidExceptionCode" xml:space="preserve">
    <value>The exception code received from the server is invalid.</value>
  </data>
  <data name="ModbusClient_InvalidProtocolIdentifier" xml:space="preserve">
    <value>The protocol identifier is invalid.</value>
  </data>
  <data name="ModbusClient_InvalidResponseFunctionCode" xml:space="preserve">
    <value>The responsed function code is invalid.</value>
  </data>
  <data name="ModbusClient_InvalidResponseMessageLength" xml:space="preserve">
    <value>The response message length is invalid.</value>
  </data>
  <data name="ModbusClient_InvalidUnitIdentifier" xml:space="preserve">
    <value>The unit identifier is invalid. Valid node addresses are in the range of 0 - 247. Use address '0' to broadcast write command to all available servers.</value>
  </data>
  <data name="ModbusClient_QuantityMustBePositiveInteger" xml:space="preserve">
    <value>Quantity must be a positive integer number. Choose the 'count' parameter such that an even number of bytes is requested.</value>
  </data>
  <data name="ModbusClient_TcpConnectionClosedUnexpectedly" xml:space="preserve">
    <value>The TCP connection closed unexpectedly.</value>
  </data>
  <data name="ModbusClient_TcpConnectTimeout" xml:space="preserve">
    <value>Could not connect within the specified time.</value>
  </data>
  <data name="ModbusClient_Unknown_Error" xml:space="preserve">
    <value>Unknonw {0} Modbus error received.</value>
  </data>
  <data name="ModbusServer_InvalidUnitIdentifier" xml:space="preserve">
    <value>The unit identifier is invalid. Valid node addresses are in the range of 1 - 247.</value>
  </data>
  <data name="ModbusServer_UnitIdentifierNotFound" xml:space="preserve">
    <value>No unit found for the specified unit identifier.</value>
  </data>
  <data name="ModbusTcpRequestHandler_NoValidRequestAvailable" xml:space="preserve">
    <value>There is no valid request available.</value>
  </data>
  <data name="Modbus_InvalidUseOfBroadcast" xml:space="preserve">
    <value>Invalid use of broadcast: Unit identifier '0' can only be used for write operations.</value>
  </data>
  <data name="Modbus_InvalidValueUShort" xml:space="preserve">
    <value>The value is invalid. Valid values are in the range of 0 - 65535.</value>
  </data>
</root>