<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>FluentModbus | FluentModbus </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="FluentModbus | FluentModbus ">
    <meta name="generator" content="docfx 2.56.2.0">
    
    <link rel="shortcut icon" href="images/icon.ico">
    <link rel="stylesheet" href="styles/docfx.vendor.css">
    <link rel="stylesheet" href="styles/docfx.css">
    <link rel="stylesheet" href="styles/main.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet"> 
    <meta property="docfx:navrel" content="toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="index.html">
                <img id="logo" class="svg" src="images/logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="article row grid">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="fluentmodbus">FluentModbus</h1>

<p><a href="https://ci.appveyor.com/project/Apollo3zehn/fluentmodbus"><img src="https://ci.appveyor.com/api/projects/status/github/apollo3zehn/fluentmodbus?svg=true&amp;branch=master" alt="AppVeyor"></a>
<a href="https://www.nuget.org/packages/FluentModbus"><img src="https://img.shields.io/nuget/v/FluentModbus.svg?label=Nuget" alt="NuGet"></a></p>
<p>FluentModbus is a .NET Standard library (2.0 and 2.1) that provides Modbus TCP/RTU server and client implementations for easy process data exchange. Both, the server and the client, implement class 0, class 1 and class 2 (partially) functions of the <a href="http://www.modbus.org/specs.php">specification</a>. Namely, these are:</p>
<p><strong>Class 0</strong></p>
<ul>
<li>FC03: ReadHoldingRegisters</li>
<li>FC16: WriteMultipleRegisters</li>
</ul>
<p><strong>Class 1</strong></p>
<ul>
<li>FC01: ReadCoils</li>
<li>FC02: ReadDiscreteInputs</li>
<li>FC04: ReadInputRegisters</li>
<li>FC05: WriteSingleCoil</li>
<li>FC06: WriteSingleRegister</li>
</ul>
<p><strong>Class 2</strong></p>
<ul>
<li>FC23: ReadWriteMultipleRegisters</li>
</ul>
<p>Please see the introduction below to get a more detailed description on how to use this library!</p>
<p>Here is a screenshot of the <a href="samples/modbus_tcp.html">sample</a> console output using a Modbus TCP server and client:</p>
<p><img src="images/sample.png" alt="Sample."></p>
<h3 id="install-the-package">Install the package</h3>
<p>Simply start a new .NET Core project with the <code>FluentModbus</code> package installed:</p>
<pre><code class="lang-powershell">PS&gt; dotnet new console
PS&gt; dotnet add package FluentModbus
</code></pre>
<h1 id="modbus-client-section">Modbus Client Section</h1>
<h2 id="modbus-tcp-client">Modbus TCP client</h2>
<p>A new Modbus TCP client can be easily created with the following code:</p>
<pre><code class="lang-cs">var client = new ModbusTcpClient();
</code></pre>
<p>Once you have an instance, connect to a server in one of the following ways:</p>
<pre><code class="lang-cs">// use default IP address 127.0.0.1 and port 502
client.Connect();

// use specified IP address and default port 502
client.Connect(IPAddress.Parse(&quot;127.0.0.1&quot;));

// use specified IP adress and port
client.Connect(new IPEndPoint(IPAddress.Parse(&quot;127.0.0.1&quot;), 502))
</code></pre>
<h2 id="modbus-rtu-client">Modbus RTU client</h2>
<p>Alternatively, a new Modbus RTU client can be created with the following code:</p>
<pre><code class="lang-cs">// use default COM port settings
var client = new ModbusRtuClient();

// use custom COM port settings:
var client = new ModbusRtuClient()
{
    BaudRate = 9600,
    Parity = Parity.None,
    StopBits = StopBits.Two
};
</code></pre>
<p>Once you have an instance, connect using a free COM port:</p>
<pre><code class="lang-cs">client.Connect(&quot;COM1&quot;);
</code></pre>
<h2 id="little-endian-vs-big-endian">Little-Endian vs. Big-Endian</h2>
<p>The Modbus specs define a big-endian data layout, i.e. the most significant byte is sent first. Opposed to this, most modern systems have little-endian memory layout. This requires to convert the data from one layout into the other whenever a Modbus register is access. Additionally, there are also Modbus servers around that work with little-endian data.</p>
<p>Due to this inconsistency it may happen that you get strange numbers from the Modbus server. In that case try one of the following <code>Connect()</code> overloads:</p>
<pre><code class="lang-cs">var client = new ModbusTcpClient(...);
client.Connect(..., ModbusEndianness.BigEndian);

var client = new ModbusRtuClient(...);
client.Connect(..., ModbusEndianness.BigEndian);
</code></pre>
<p>When you are explicitly specifying the endianness of the data layout in the constructor, the library will correctly handle the data conversion for you.</p>
<p>By default, this library expects little-endian data for compatibility reasons.</p>
<h2 id="a-few-words-to-spant">A few words to <code>Span&lt;T&gt;</code></h2>
<p>The returned data of the read functions (FC01 to FC04) are always provided as <code>Span&lt;T&gt;</code> (<a href="https://msdn.microsoft.com/en-us/magazine/mt814808.aspx">What is this?</a>). In short, a <code>Span&lt;T&gt;</code> is a simple view of the underlying memory. With this type, the memory can be interpreted as <code>byte</code>, <code>int</code>, <code>float</code> or any other value type. A conversion from <code>Span&lt;byte&gt;</code> to other types can be efficiently achieved through:</p>
<pre><code class="lang-cs">Span&lt;byte&gt; byteSpan = new byte[] { 1, 2, 3, 4 }.AsSpan();
Span&lt;int&gt; intSpan = MemoryMarshal.Cast&lt;byte, int&gt;(byteSpan);
Span&lt;float&gt; floatSpan = MemoryMarshal.Cast&lt;int, float&gt;(intSpan);
</code></pre>
<p>You can then access it like a any other array:</p>
<pre><code class="lang-cs">var floatValue = myFloatSpan[0];
</code></pre>
<p>The data remain unchanged during all of these calls. <em>Only the interpretation changes.</em> However, one disadvantage is that this type cannot be used in all code locations (e.g. in <code>async</code> functions). Therefore, if you run into these limitations, you can simply convert the returned data to a plain array (which is essentially a copy operation):</p>
<pre><code class="lang-cs">float[] floatArray = floatSpan.ToArray();
</code></pre>
<h2 id="read-data">Read data</h2>
<h3 id="read-integer-or-float">Read integer or float</h3>
<p>First, define the unit identifier, the starting address and the number of values to read (count):</p>
<pre><code class="lang-cs">var unitIdentifier = (byte)0xFF; // 0x00 and 0xFF are the defaults for TCP/IP-only Modbus devices.
var startingAddress = (ushort)0;
var count = (ushort)10;
</code></pre>
<p>Then, read the data:</p>
<pre><code class="lang-cs">var shortData = client.ReadHoldingRegisters&lt;short&gt;(unitIdentifier, startingAddress, count);
</code></pre>
<p>As explained above, you can <em>interpret</em> the data in different ways using the generic overloads, which does the <code>MemoryMarshal.Cast&lt;T1, T2&gt;</code> work for you:</p>
<pre><code class="lang-cs">// interpret data as float
var floatData = client.ReadHoldingRegisters&lt;float&gt;(unitIdentifier, startingAddress, count);
var firstValue = floatData[0];
var lastValue = floatData[floatData.Length - 1];

Console.WriteLine($&quot;Fist value is {firstValue}&quot;);
Console.WriteLine($&quot;Last value is {lastValue}&quot;);
</code></pre>
<p>If you want to keep the data for later use or you want to use the Modbus client in asynchronous methods, convert the <code>Span&lt;T&gt;</code> into a normal array with <code>ToArray()</code>:</p>
<pre><code class="lang-cs">async byte[] DoAsync()
{
    var client = new ModbusTcpClient();
    client.Connect(...);

    await &lt;awaitsomething&gt;;

    return client.ReadHoldingRegisters(1, 2, 3).ToArray();
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> The generic overloads shown here are intended for normal use. Compared to that, the non-generic overloads like <code>client.ReadHoldingRegisters()</code> have slightly better performance. However, they achieve this by doing fewer checks and conversions. This means, these methods are less convenient to use and only recommended in high-performance scenarios, where raw data (i.e. byte arrays) are moved around.</p>
</blockquote>
<h3 id="read-boolean">Read boolean</h3>
<p>Boolean values are returned as single bits (1 = true, 0 = false), which are packed into bytes. If you request 10 booleans you get a <code>Span&lt;byte&gt;</code> in return with a length of <code>2</code> bytes. In this example, the remaining <code>6</code> bits are fill values.</p>
<pre><code class="lang-cs">var unitIdentifier = (byte)0xFF;
var startingAddress = (ushort)0;
var quantity = (ushort)10;

var boolData = client.ReadCoils(unitIdentifier, startingAddress, quantity);
</code></pre>
<p>You can check if a certain bit (here: <code>bit 2</code>) is set with:</p>
<pre><code class="lang-cs">var position = 2;
var boolValue = ((boolData[0] &gt;&gt; position) &amp; 1) &gt; 0;
</code></pre>
<p>See also <a href="https://stackoverflow.com/questions/47981/how-do-you-set-clear-and-toggle-a-single-bit">this</a> overview to understand how to manipulate single bits.</p>
<h2 id="write-data">Write data</h2>
<h3 id="write-integer-or-float">Write integer or float</h3>
<p>The following example shows how to write the number <code>4263</code> to the server:</p>
<pre><code class="lang-cs">var unitIdentifier = (byte)0xFF;
var startingAddress = (ushort)0;
var registerAddress = (ushort)0;
var quantity = (ushort)10;

var shortData = new short[] { 4263 };
client.WriteSingleRegister(unitIdentifier, registerAddress, shortData);

// read back from server to prove correctness
var shortDataResult = client.ReadHoldingRegisters&lt;short&gt;(unitIdentifier, startingAddress, 1);
Console.WriteLine(shortDataResult[0]); // should print '4263'
</code></pre>
<blockquote>
<p><strong>Note</strong>: The Modbus protocol defines a basic register size of 2 bytes. Thus, the write methods require input values (or arrays) with even number of bytes (2, 4, 6, ...). This means that a call to <code>client.WriteSingleRegister(0, 0, new byte { 1 })</code> will not work, but <code>client.WriteSingleRegister(0, 0, new short { 1 })</code> will do. Since the client validates all your inputs (and so the server does), you will get notified if anything is wrong.</p>
</blockquote>
<p>If you want to write float values, the procedure is the same as shown previously using the generic overload:</p>
<pre><code class="lang-cs">var floatData = new float[] { 1.1F, 9557e3F };
client.WriteMultipleRegisters(unitIdentifier, startingAddress, floatData);
</code></pre>
<h3 id="write-boolean">Write boolean</h3>
<p>It's as simple as:</p>
<pre><code class="lang-cs">client.WriteSingleCoil(unitIdentifier, registerAddress, true);
</code></pre>
<h1 id="modbus-server-section">Modbus Server Section</h1>
<h2 id="modbus-tcp-server">Modbus TCP server</h2>
<p>First, you need to instantiate the Modbus TCP server:</p>
<pre><code class="lang-cs">var server = new ModbusTcpServer();
</code></pre>
<p>Then you can start it:</p>
<pre><code class="lang-cs">server.Start();
</code></pre>
<h3 id="option-1-asynchronous-operation">Option 1 (asynchronous operation)</h3>
<p>There are two options to operate the server. The first one, which is the default, is asynchronous operation. This means all client requests are handled immediately. However, asynchronous operation requires a synchronization of data access, which can be accomplished using the <code>lock</code> keyword:</p>
<pre><code class="lang-cs">var cts = new CancellationTokenSource();
var random = new Random();
var server = new ModbusTcpServer();

server.Start();

while (!cts.IsCancellationRequested)
{
    var intData = server.GetHoldingRegisterBuffer&lt;int&gt;();

    // lock is required to synchronize buffer access between
    // this application and one or more Modbus clients
    lock (server.Lock)
    {
        intData[20] = random.Next(0, 100);
    }

    // update server buffer content only once per second
    await Task.Delay(TimeSpan.FromSeconds(1));
}

server.Dispose();
</code></pre>
<h3 id="option-2-synchronous-operation">Option 2 (synchronous operation)</h3>
<p>The second mode is the <em>synchronous</em> mode, which is useful for advanced scenarios, where a lock mechanism is undesirable. In this mode, the hosting application is responsible to trigger the data update method (<code>server.Update()</code>) regularly:</p>
<pre><code class="lang-cs">var cts = new CancellationTokenSource();
var random = new Random();
var server = new ModbusTcpServer(isAsynchronous: false);

server.Start();

while (!cts.IsCancellationRequested)
{
    var intData = server.GetHoldingRegisterBuffer&lt;int&gt;();
    intData[20] = random.Next(0, 100);

    server.Update();

    await Task.Delay(TimeSpan.FromMilliseconds(100));
}
</code></pre>
<p>Note that in the second example, the <code>Task.Delay()</code> period is much lower. Since we want coordinated access between the application and the clients <em>without</em> locks, we need to ensure that at certain points in time, the application is safe to access the buffers. This is the case when the <code>IsReady</code> propery is <code>true</code> (when all client requests have been served). After the application finished manipulating the server data, it triggers the server to serve all accumulated client requests (via the <code>Update()</code> method). Finally, the process repeats.</p>
<h2 id="modbus-rtu-server">Modbus RTU server</h2>
<p>When you need a Modbus RTU server, you need to instantiate it like this providing a <code>unitIdentifier</code>, which must be in the range of 1..247 and unique for each Modbus server or slave, respectively:</p>
<pre><code class="lang-cs">var server = new ModbusRtuServer(unitIdentifier: 1);
</code></pre>
<p>Then you can start it e.g. on COM port 1:</p>
<pre><code class="lang-cs">server.Start(port: &quot;COM1&quot;);
</code></pre>
<p>As for the TCP server, there are two options to operate the server (synchronous and asynchronous). See above for details.</p>
<h2 id="input-and-holding-registers">Input and Holding registers</h2>
<p>As written above in the client section, the Modbus specs define a big-endian data layout, i.e. the most significant byte is sent first. Opposed to this, most modern systems have little-endian memory layout. This requires to convert the data from one layout into the other whenever a Modbus register is access. Additionally, there are also Modbus servers around that work with little-endian data.</p>
<p>Both Modbus servers (TCP and RTU) are enabled to work with both kinds of byte layouts. Originally, the Modbus specs only define 2-byte (16-bit) registers but with the FluentModbus servers you are able to overcome this limitation and interpret the data as any value type you want (more details to this can be found in the <code>Span&lt;T&gt;</code> section above).</p>
<p>Since the actual data type in the registers is unknown, the FluentModbus server cannot handle the data layout conversion in a fully automated way. For this, a little help of the user is required:</p>
<pre><code class="lang-cs">// Get a reference to the holding registers.
var registers = server.GetHoldingRegisters();

// Write a double value (0.85) to address 1.
// With an 8-byte double value, this will be written into
// the holding registers 1 - 4.
registers.SetBigEndian&lt;double&gt;(address: 1, value: 0.85);
</code></pre>
<blockquote>
<p><strong>Note:</strong> Always keep the data type in mind to avoid setting an integer if you wanted to write a short value:</p>
</blockquote>
<pre><code class="lang-cs">// This will write an 4 byte integer
registers.SetBigEndian(address: 1, value: 99);

// These will write a 2 byte short
registers.SetBigEndian(address: 1, value: (short)99);
registers.SetBigEndian&lt;short&gt;(address: 1, value: 99);
</code></pre>
<p>There are complementary methods for little-endian data and methods for reading data. The full list of <code>Span&lt;short&gt;</code> extension methods is:</p>
<pre><code class="lang-cs">void registers.SetBigEndian&lt;T&gt;(...);
void registers.SetLittleEndian&lt;T&gt;(...);

Span&lt;short&gt; registers.GetBigEndian&lt;T&gt;(...);
Span&lt;short&gt; registers.GetLittleEndian&lt;T&gt;(...);
</code></pre>
<h2 id="coils-and-discrete-inputs">Coils and Discrete Inputs</h2>
<p>There is not endianness problem with bit-oriented data, so no special methods are required here, but to ease access there are some convenience methods:</p>
<pre><code class="lang-cs">// Get buffer
var coils = server.GetCoils(); // or server.GetDiscreteInputs()

// Set bit.
coils.Set(address: 1, value: true);
var value = coils.Get(address: 1); // should return 'true'

// Unset bit
coils.Set(address: 2, value: false);
var value = coils.Get(address: 1); // should return 'false'

// Toggle bit
coils.Toggle(address: 2, value: false);
var value = coils.Get(address: 1); // should return 'true'
</code></pre>
<h2 id="frame-validation">Frame validation</h2>
<p>It might happen that a server should not support all Modbus functions or only a limited set of registers. In that case simply assign a validation action to the server:</p>
<pre><code class="lang-cs">
var server = new ModbusTcpServer()
{
    RequestValidator = (functionCode, address, quantityOfRegisters) =&gt;
    {
        if (functionCode == ModbusFunctionCode.WriteSingleRegister)
            return ModbusExceptionCode.IllegalFunction;

        else if (address &lt; 5 || address &gt; 15)
            return ModbusExceptionCode.IllegalDataAddress;

        else
            return ModbusExceptionCode.OK;
    }
};
</code></pre>
<p>See a full example in the <a href="samples/modbus_validator.html">sample</a> section.</p>
<h1 id="see-also">See also</h1>
<p>This implementation is based on <a href="http://www.modbus.org/specs.php">http://www.modbus.org/specs.php</a>:</p>
<ul>
<li>MODBUS APPLICATION PROTOCOL SPECIFICATION V1.1b3</li>
<li>MODBUS over Serial Line Specification and Implementation Guide V1.02</li>
<li>MODBUS MESSAGING ON TCP/IP IMPLEMENTATION GUIDE V1.0b</li>
</ul>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/Apollo3zehn/FluentModbus/blob/master/doc/index.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Copyright © 2019 Vincent Wilms
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="styles/docfx.js"></script>
    <script type="text/javascript" src="styles/main.js"></script>
  </body>
</html>
